#!/usr/bin/env python
#
# This script will read a netcdf file, duplicate the first year's data
# N times, and prepend the duplicate data to the file.
#

import abc, argparse, datetime, glob, os, ozflux_logging, math, numpy, shutil, sys, traceback
from typing import Callable
from netCDF4 import Dataset, Variable

# leap years are a myth...actually, lpj-guess doesn't account for leap
# years, so we won't either.
DAYS_PER_YEAR = 365
MINUTES_PER_DAY = 24 * 60
VARIABLE_NAME = "forcing_data"
NUM_VARIABLES = 11

class DuplicateOptions:
	"""
	Class for storing CLI options.
	"""
	def __init__(self, log: ozflux_logging.LogLevel, files: list[str]
		, nyear: int, show_progress: bool):
		self.log_level = log
		self.files = files
		self.nyears = nyear
		self.show_progress = show_progress

class IWeatherGenerator(abc.ABC):
	"""
	Interface for a weather generator.
	"""
	@abc.abstractmethod
	def generate_weather(self, data: list[float], year_len: int, nyear: int) -> list[float]:
		"""
		Generate N years' weather data.
		@param data: The base data to use for generation.
		@param year_len: Number of elements (timesteps) per year.
		@param nyear: Number of years' data to generate. Output array
					  length should be len(data) + nyear * year_len.
		"""
		...

class DuplicateGenerator(IWeatherGenerator):
	"""
	Weather generator implementation which just repeatedly duplicates
	the first years' data.
	"""
	def generate_weather(self, data: list[float], year_len: int, nyear: int) -> list[float]:
		"""
		See base class doco for usage instructions.
		"""
		first_years_data = data[:year_len]
		return first_years_data * nyear + data

class GaussianGenerator(IWeatherGenerator):
	"""
	Weather generator implementation which generates data from a normal
	distribution of sampled data.
	"""
	def generate_weather(self, data: list[float], year_len: int, nyear: int) -> list[float]:
		"""
		See base class doco for usage instructions.
		"""
		# Create an array in which each element is an array of all
		# values for that particular day of year, across all years.
		timesteps = [[] for _ in range(year_len)]
		for i in range(len(data)):
			doy = i % year_len
			timesteps[doy].append(data[i])

		# Get mean/sd by day of year.
		means = [0.0] * year_len
		sds = [0.0] * year_len
		for i in range(year_len):
			means[i] = numpy.mean(timesteps[i])
			sds[i] = numpy.std(timesteps[i])

		n = year_len * nyear
		samples = [0.0] * n
		for i in range(n):
			doy = i % year_len
			samples[i] = numpy.random.normal(means[doy], sds[doy])

		return samples

global show_progress
show_progress: bool

def log_progress(progress: float):
	global show_progress
	if show_progress:
		print("Working: %.2f%%\r" % (100 * progress) )

def prepend(data: list[list[float]], nc: Dataset):
	"""
	Prepend the 2d array to the specified .nc file.

	@param data: A list of list of floats. Each sub list should be the
	yearly data for a single variable.
	"""
	if len(data) < 1:
		ozflux_logging.log_warning("Attempted to prepend empty array. Probably a bug.")
		return
	n = len(data[0])
	# Prepend one row at a time (in reverse - so 1st row is prepened last).
	nc.variables[VARIABLE_NAME][:] = numpy.insert(
		nc.variables[VARIABLE_NAME],
		0,
		numpy.transpose(data),
		axis = 0
	)
	# for i in reversed(range(n)):
	# 	row = [x[i] for x in data]
	# 	nc.variables[VARIABLE_NAME][:] = numpy.insert(
	# 		nc.variables[VARIABLE_NAME],
	# 		0,
	# 		row, # fixme - probably need to convert to right format
	# 		axis = 0
	# 	)

def get_timesteps_per_year(nc_file: Dataset) -> int:
	"""
	Read the .nc file metadata and determine the number of timesteps per
	variable per year.
	"""
	timestep = int(nc_file.time_step) # in minutes
	timesteps_per_day = MINUTES_PER_DAY / timestep
	return int(timesteps_per_day * DAYS_PER_YEAR)

def extract_variable(index: int, variable: Variable) -> list[float]:
	"""
	Extract data for the i-th variable in the specified netcdf variable.
	The input variable should be the "met_forcings" variable in the
	processed data.
	"""
	# n = int(math.floor(len(variable)))
	# data = [0.0] * n
	# for i in range(n):
	# 	data[i] = variable[i][index]
	# return data
	return variable[:,index]

def generate_weather(in_file: str, nyear: int
	, progress_callback: Callable[[float], None]):
	"""
	Generate N years' data and prepend the result to the .nc file.
	"""
	ozflux_logging.log_information("----- Processing %s -----" % in_file)
	with Dataset(in_file, "r+", format="NETCDF4") as nc:
		timesteps_per_year = get_timesteps_per_year(nc)
		generator = GaussianGenerator()

		ozflux_logging.log_information("Reading data")
		data_by_variable = [[]] * NUM_VARIABLES
		for i in range(NUM_VARIABLES):
			data_by_variable[i] = extract_variable(i, nc[VARIABLE_NAME])

		ozflux_logging.log_information("Generating met data")
		for i in range(nyear):
			year = [[]] * NUM_VARIABLES
			for j in range(NUM_VARIABLES):
				year[j] = generator.generate_weather(data_by_variable[j], timesteps_per_year, 1)
			prepend(year, nc)
			progress_callback((i + 1) / nyear)

def main(opts: DuplicateOptions):
	"""
	Main function; creates the benchmark configs.
	"""
	step_size = 1 / len(opts.files)
	for i in range(len(opts.files)):
		step_start = i / len(opts.files)
		generate_weather(opts.files[i], opts.nyears
			, lambda p: log_progress(step_start + step_size * p))

def parse_args(args: list[str]) -> DuplicateOptions:
	"""
	Parse CLI arguments.
	"""
	parser = argparse.ArgumentParser(args[0], description = "Generate met data in a netcdf file.")
	parser.add_argument("-v", "--verbosity", type = int, nargs = "?", default = ozflux_logging.LogLevel.INFORMATION, help = "Logging verbosity (1-5, default 3)")
	parser.add_argument("files", nargs = "+", help = "Input .nc files to be processed")
	parser.add_argument("-n", "--num-years", type = int, nargs = "?", default = "1", help = "Number of years of data to generate")
	parser.add_argument("-p", "--show-progress", action = "store_true", help = "Report progress")
	result = parser.parse_args(args[1:])
	return DuplicateOptions(result.verbosity, result.files
		, result.num_years, result.show_progress)

if __name__ == "__main__":
	# Parse CLI args
	opts = parse_args(sys.argv)

	# todo: rethink logging
	ozflux_logging.global_log_level = opts.log_level
	show_progress = opts.show_progress

	try:
		# Actual logic is in main().
		main(opts)
	except BaseException as error:
		# Basic error handling.
		ozflux_logging.log_error(traceback.format_exc())
		exit(1)


