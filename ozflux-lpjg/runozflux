#!/usr/bin/env python
#
# A script to run ozflux site-level simulations in LPJ-Guess.
#

import traceback
import ozflux_common
import ozflux_parallel
import subprocess, shutil

from argparse import ArgumentParser
from subprocess import PIPE, STDOUT
from ozflux_logging import *
from ozflux_netcdf import *
from sys import argv
from typing import Callable
from ozflux_parallel import JobManager

# Regular expression matching progress messages from LPJ-Guess.
_PROGRESS_REGEX = r"[^\d]+(\d+)% complete.*"

# Regular expression which matches the output directory in an instruction file.
_OUTDIR_REGEX = r"[ \t]*outputdirectory[ \t]+\"([^\"]+)\".*"

# Regular expression matching an enabled output file.
_OUTFILE_REGEX = r"[ \t]*file_[^\"]+\"([^\"]+)\".*"

# Name of the ozflux outputs instruction file.
_OUTPUTS_INS = "outputs.ins"

_ALL_SITES = [
	"AdelaideRiver",
	"AliceSpringsMulga",
	"Boyagin",
	"Calperum",
	"CapeTribulation",
	"Collie",
	"CowBay",
	"CumberlandPlain",
	"DalyPasture",
	"DalyUncleared",
	"DryRiver",
	"Emerald",
	"FoggDam",
	"Gingin",
	"GreatWesternWoodlands",
	"HowardSprings",
	"Litchfield",
	"Longreach",
	"Otway",
	"RedDirtMelonFarm",
	"Ridgefield",
	"RiggsCreek",
	"RobsonCreek",
	"Samford",
	"SilverPlains",
	"SturtPlains",
	"TiTreeEast",
	"Tumbarumba",
	"WallabyCreek",
	"Warra",
	"Whroo",
	"WombatStateForest",
	"Yanco"
]

class Options:
	"""
	Class for storing CLI arguments from the user.

	@param log: Log level.
	@param files: Input files.
	@param out: Output file.
	@param prog: True to write progress messages, 0 otherwise.
	@param parallel: Number of simulations to run in parallel.
	@param repos: Path to one or more lpj-guess repositories.
	@param no_build: If true, the model will not be built before being run.
	"""
	def __init__(self, log : LogLevel, sites: list[str], out: str, prog: bool,
		parallel: int, repos: list[str], no_build: bool):
		self.log_level = log
		self.sites = sites
		self.out_dir = out
		self.report_progress = prog
		self.parallel = parallel
		self.repos = repos
		self.build = not no_build

class SiteRunner(ozflux_parallel.Task):
	def __init__(self, ins_file: str, guess: str):
		self.ins_file = ins_file
		self.guess_path = guess

	def exec(self, pcb: Callable[[float], None]):
		ins = self.ins_file
		cmd = [self.guess_path, "-input", "nc", ins]
		wd = os.path.dirname(self.ins_file)
		run_proc(cmd, wd, lambda: log_error("Failed log run '%s'" % ins))
		proc = subprocess.Popen(cmd, cwd = wd, encoding = "utf-8", stdout = PIPE
			, stderr = STDOUT)
		pattern = re.compile(_PROGRESS_REGEX)
		while proc.poll() is None:
			msg = proc.stdout.readline()
			match = re.match(pattern, msg)
			if match is not None:
				percent_str = match.group(1)
				progress = float(percent_str) / 100
				pcb(progress)

		if proc.returncode != 0:
			site = os.path.basename(ins)
			m = "Error in %s: %s"
			raise subprocess.CalledProcessError(m % (site, proc.stdout))

class GuessBuilder(ozflux_parallel.Task):
	def __init__(self, repo: str):
		self.repo = repo
	def run(self, cmd: list[str], cwd: str):
		run_proc(cmd, cwd, lambda: log_error("Failed to build '%s'" % self.repo))
	def exec(self, pcb: Callable[[float], None]):
		log_diagnostic("Building %s..." % self.repo)
		BUILDDIR = "build"
		self.run([
			"cmake",
			"-DCMAKE_BUILD_TYPE=Release",
			"-DCMAKE_CXX_STANDARD=14",
			"-DCMAKE_CXX_STANDARD_REQUIRED=ON",
			"-DCMAKE_CXX_EXTENSIONS=ON",
			"-B",
			BUILDDIR
		], cwd = self.repo)
		self.run(["cmake", "--build", BUILDDIR, "-j", str(opts.parallel)], self.repo)

def run_proc(cmd: list[str], cwd: str, err_callback: Callable):
	res = subprocess.run(cmd, cwd = cwd, encoding = "utf-8", stdout = PIPE
		, stderr = STDOUT)
	if res.returncode != 0:
		try:
			err_callback()
		except BaseException as error:
			log_error("Error handlin routine threw an error")
			log_error(traceback.format_exc())
		log_error(res.stdout)
		res.check_returncode()

def parse_args(argv: list[str]) -> Options:
	"""
	Parse CLI arguments, return a parsed options object.

	@param argv: Raw CLI arguments.

	@return Parsed Options object.
	"""
	parser = ArgumentParser(prog=argv[0], description = "Run ozflux site-level simulations in LPJ-Guess")
	parser.add_argument("-v", "--verbosity", type = int, help = "Logging verbosity (1-5, default 3)", nargs = "?", const = LogLevel.INFORMATION, default = LogLevel.INFORMATION)
	parser.add_argument("-o", "--out-dir", help = "Path to desired output directory.")
	parser.add_argument("-p", "--show-progress", action = "store_true", help = "Report progress")
	parser.add_argument("-P", "--max-parallel", default = multiprocessing.cpu_count(), type = int, help = "Max number of simulations to run in parallel. Defaults to number of available processors.")
	parser.add_argument("-r", "--repository", action = "append", help = "Path to one or more lpj-guess repositories")
	parser.add_argument("-b", "--no-build", action = "store_true", help = "Don't build the model before running")
	parser.add_argument("--version", action = "version", version = "%(prog)s " + ozflux_common.VERSION)

	g = parser.add_mutually_exclusive_group()
	g.add_argument("-s", "--site", action = "append", help = "Specify one or more sites to run (requires multiple -s/--site options)")
	g.add_argument("-a", "--all-sites", action = "store_true", help = "Run all sites")

	p = parser.parse_args(argv[1:])

	sites = _ALL_SITES if p.all_sites else p.site

	return Options(p.verbosity, sites, p.out_dir, p.show_progress
			, p.max_parallel, p.repository, p.no_build)

def get_guess(repo: str) -> str:
	"""
	Get the lpj-guess path for the specified repository.
	"""
	guess = os.path.join(repo, "build", "guess")
	if os.name == "nt":
		guess += ".exe"
	return guess

def build_repos(repos: list[str]):
	"""
	Build the model in each specified repository.

	@param repos: List of lpj-guess repository paths.
	"""
	log_information("Building...")
	builder = JobManager()
	for repo in opts.repos:
		builder.add_job(GuessBuilder(repo))

	set_show_progress(False)
	builder.run_parallel(opts.parallel)
	set_show_progress(opts.report_progress)

def run_sites(repos: list[str], sites: list[str]):
	"""
	Run the model for all sites in all repositories.

	@param repos: List of lpj-guess repository paths.
	@param sites: List of ozflux sites to run.
	"""
	job_manager = JobManager()
	log_information("Running...")
	for repo in opts.repos:
		repo = os.path.abspath(repo)
		guess = get_guess(repo)
		for site in opts.sites:
			ins = os.path.join(get_site_path(repo, site), f"{site}.ins")
			job_manager.add_job(SiteRunner(ins, guess))
	job_manager.run_parallel(opts.parallel)

def ozflux_path(repo: str) -> str:
	"""
	Return the path to the ozflux directory in the given repository.

	@param repo: Path to an lpj-guess repository.
	"""
	return os.path.join(repo, "benchmarks", "ozflux")

def get_site_path(repo: str, site: str) -> str:
	"""
	Return the path to the site in the given repository.

	@param repo: Path to an lpj-guess repository.
	@param site: Name of an ozflux site.
	"""
	return os.path.join(ozflux_path(repo), site)

def get_outputs_ins(repo: str) -> str:
	"""
	Return the path to the outputs.ins instruction file for the specified repo.

	@param repo: Path to an lpj-guess repository.
	"""
	return os.path.join(ozflux_path(repo), _OUTPUTS_INS)

def get_enabled_outputs(repo: str) -> tuple[str, list[str]]:
	"""
	Get the list of outputs enabled for the specified repository.

	@param repo: Path to an lpj-guess repository.

	Returns a tuple of (output path, list of enabled outputs).
	"""
	ins = get_outputs_ins(repo)
	file_pattern = re.compile(_OUTFILE_REGEX)
	dir_pattern = re.compile(_OUTDIR_REGEX)
	outputs: list[str] = []
	out_path: str = None
	with open(ins, "r") as file:
		for line in file:#.readlines():
			match = re.match(file_pattern, line)
			if match is not None:
				outputs.append(match.group(1))
			match = re.match(dir_pattern, line)
			if match is not None:
				out_path = match.group(1)
	if out_path is None:
		raise ValueError(f"Unknown output path for {repo}")
	return (out_path, outputs)

def concat_file(infile: str, outfile: str, header: bool):
	"""
	Concatenate the contents of infile to outfile.

	@param infile: Input file path.
	@param outfile: Output file path.
	@param header: True to copy file header. False otherwise.
	"""
	with open(infile, "rb") as fin:
		if not header:
			fin.readline()
		with open(outfile, "ab") as fout:
			shutil.copyfileobj(fin, fout)

def copy_outputs_repo(repo: str, sites: list[str], out: str):
	"""
	Copy all outputs of the specified sites in the given repo into the specified
	output directory.

	@param repo: Path to an lpj-guess repository.
	@param sites: List of sites for which outputs will be copied.
	@param out: Output directory.
	"""
	(outputs_path, outputs) = get_enabled_outputs(repo)
	i = 0
	for site in sites:
		site_path = get_site_path(repo, site)
		site_out = os.path.join(site_path, outputs_path)
		for output in outputs:
			infile = os.path.join(site_out, output)
			outfile = os.path.join(out, os.path.basename(output))
			concat_file(infile, outfile, i == 0)
		i += 1

def copy_outputs(repos: list[str], sites: list[str], out_dir: str):
	"""
	Concatenate all outputs from all sites for each specified repository into
	the specified output directory.

	@param repos: List of paths to lpj-guess repositories.
	@param sites: List of sites for which outputs will be copied.
	@param out_dir: Output directory.
	"""
	out_dir = os.path.abspath(out_dir)
	log_information("Copying outputs...")
	for repo in repos:
		repo_name = os.path.basename(repo)
		log_diagnostic(f"Copying outputs from repository '{repo_name}'")

		# Delete output directory if it already exists, then create it anew.
		repo_out = os.path.join(out_dir, repo_name)
		if os.path.exists(repo_out):
			shutil.rmtree(repo_out)
		os.makedirs(repo_out)

		copy_outputs_repo(repo, sites, repo_out)

def main(opts: Options):
	"""
	Main function.

	@param opts: Parsed CLI options provided by the user.
	"""
	if opts.build:
		build_repos(opts.repos)
	run_sites(opts.repos, opts.sites)
	copy_outputs(opts.repos, opts.sites, opts.out_dir)

if __name__ == "__main__":
	# Parse CLI args
	opts = parse_args(argv)

	set_log_level(opts.log_level)
	set_show_progress(opts.report_progress)

	try:
		# Actual logic is in main().
		main(opts)
	except BaseException as error:
		# Basic error handling.
		log_error(traceback.format_exc())
		exit(1)
