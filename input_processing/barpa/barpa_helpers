# Helper functions for BARPA processing scripts. This file should be sourced.

die() { echo "$*" >&2; exit 1; }

BARPA_BASE_PATH=/g/data/py18

# BARPA directory structure:
#
#    /g/data/py18
#    |-- <product>
#      |-- <nature of data> or <project_id>
#         |-- <MIP-era>
#              |-- <activity_id>
#                   |-- <domain_id>
#                        |-- <RCM-institution_id>
#                             |-- <driving_source_id>
#                                  |-- <driving_experiment_id>
#                                       |-- <driving_variant_label>
#                                            |-- <source_id>
#                                                 |-- <version_realisation>
#                                                      |-- <freq>
#                                                           |-- <variable_id>
#                                                               |-- <version>
#

#
# Enumerate all input files for the given configuration.
#
# This uses all of the variables set in barpa_config, and, additionally, the
# following variables: VARIABLE_ID
#
enumerate_files() {
	BPATH="${BARPA_BASE_PATH}/${PRODUCT}/${PROJECT}/${MIP_ERA}/${ACTIVITY_ID}"
	BPATH="${BPATH}/${DOMAIN_ID}/${RCM_INSTITUTION}/${DRIVING_SOURCE_ID}"
	BPATH="${BPATH}/${DRIVING_EXPERIMENT_ID}/${DRIVING_VARIANT_LABEL}"
	BPATH="${BPATH}/${SOURCE_ID}/${VERSION_REALISATION}/${FREQ}/${VARIABLE_ID}"
	BPATH="${BPATH}/${VERSION}"
	echo "${BPATH}"/*.nc
}

#
# Get a filename for a specific start/end date in the BARPA format.
#
# Requires two arguments:
# 1. Start date in YYYYMM format
# 2. End   date in YYYYMM format
#
# This also uses all of the variables set in barpa_config.
#
get_barpa_file_name() {
	DATE_START="${1}"
	DATE_END="${2}"

	# tas_AUS-15_ACCESS-ESM1-5_historical_r6i1p1f1_BOM_BARPA-R_v1-r1_1hr_197901-197912.nc
	echo "${VARIABLE_ID}_${DOMAIN_ID}_${DRIVING_SOURCE_ID}_${DRIVING_EXPERIMENT_ID}_${DRIVING_VARIANT_LABEL}_${RCM_INSTITUTION}_${SOURCE_ID}_${VERSION_REALISATION}_${FREQ}_${DATE_START}_${DATE_END}.nc"
}

#
# Get the start date of the given input file, in YYYYMM format, by parsing the
# filename with a regular expression. Requires one argument:
#
# 1. The file name.
#
get_start_date() {
	FILE_NAME="$(basename "${1}")"
	echo "${FILE_NAME}" | sed -r 's/.*([0-9]{6})-[0-9]{6}\.nc/\1/g'
}

#
# Get the end date of the given input file, in YYYYMM format, by parsing the
# filename with a regular expression. Requires one argument:
#
# 1. The file name.
#
get_end_date() {
	FILE_NAME="$(basename "${1}")"
	echo "${FILE_NAME}" | sed -r 's/.*([0-9]{6})\.nc/\1/g'
}

# Return the smaller of two numbers. Requires 2 arguments (the two numbers).
min() {
	X="${1:-}"
	Y="${2:-}"

	if [ -z "${X}" -a -z "${Y}" ]; then die "X and Y are both zero"; fi

	if [ -z "${X}" ]; then echo "${Y}"; return; fi
	if [ -z "${Y}" ]; then echo "${X}"; return; fi
	echo "$((X < Y ? X : Y))"
}

# Return the smaller of two numbers. Requires 2 arguments (the two numbers).
max() {
	X="${1:-}"
	Y="${2:-}"

	if [ -z "${X}" -a -z "${Y}" ]; then die "X and Y are both zero"; fi

	if [ -z "${X}" ]; then echo "${Y}"; return; fi
	if [ -z "${Y}" ]; then echo "${X}"; return; fi
	echo "$((X > Y ? X : Y))"
}

# Submit a script via qsub iff DRY_RUN is not 1. Requires 1 argument (the
# script).
submit() {
	if [ ${DRY_RUN} = 1 ]
	then
		echo 1
	else
		qsub "${1}"
	fi
}

#
# This function generates (and calls submit on) a script which does a cdo
# mergetime operation on all .nc files in the specified input directory.
#
# Requires $N arguments:
#
# 1. Input directory path.
# 2. Output file name and path.
# 3. Job name.
# 4. Dependencies specified as a colon-delimited list of PBS job IDs.
#
# This function also requires some other variables defined in barpa_config.
#
generate_mergetime_script() {
	IN_DIR="${1}"
	OUT_FILE="${2}"
	JOB_NAME="${3}"
	DEPS="${4}"

	SCRIPT_FILE="${SCRIPT_DIR}/${JOB_NAME}"

	cat <<EOF >"${SCRIPT_FILE}"
#!/usr/bin/env bash
#PBS -l ncpus=1
#PBS -l walltime=48:00:00
#PBS -l mem=64GB
#PBS -q normal
#PBS -l wd
#PBS -j oe
#PBS -m abe
#PBS -M ${PBS_EMAIL}
#PBS -P ${PBS_PROJECT}
#PBS -p ${PBS_PRIORITY}
#PBS -l storage=${PBS_STORAGE}
#PBS -N ${JOB_NAME}
#PBS -o ${LOG_DIR}/${JOB_NAME}.log
#PBS -W depend=afterok:${DEPS}

set -euo pipefail

module purge
module load netcdf cdo nco

IN_DIR="${IN_DIR}"
LOG_DIR="${LOG_DIR}"

IN_FILES="\${IN_DIR}"/*.nc
OUT_FILE="${OUT_FILE}"
PROGRESS_LOG="\${LOG_DIR}/${JOB_NAME}.progress.log"

cdo -O -L -v mergetime "\${IN_DIR}"/*.nc "\${OUT_FILE}" | tee "\${PROGRESS_LOG}"

EOF
	chmod u+x "${SCRIPT_FILE}"
	submit "${SCRIPT_FILE}"
}

#
# This function generates (and calls submit on) a script which does a cdo
# mergetime operation on all .nc files in the specified input directory.
#
# Requires $N arguments:
#
# 1. Input file path.
# 2. Output file path.
# 3. Job name.
# 4. Dependencies specified as a colon-delimited list of PBS job IDs.
#
# This function also requires some other variables defined in barpa_config.
#
generate_rechunk_script() {
	IN_FILE="${1}"
	OUT_FILE="${2}"
	JOB_NAME="${3}"
	DEPS="${4}"

	SCRIPT_FILE="${SCRIPT_DIR}/${JOB_NAME}"
	cat <<EOF >"${SCRIPT_FILE}"
#!/usr/bin/env bash
#PBS -l ncpus=1
#PBS -l walltime=48:00:00
#PBS -l mem=64GB
#PBS -q normal
#PBS -l wd
#PBS -j oe
#PBS -m abe
#PBS -M ${PBS_EMAIL}
#PBS -P ${PBS_PROJECT}
#PBS -p ${PBS_PRIORITY}
#PBS -l storage=${PBS_STORAGE}
#PBS -N ${JOB_NAME}
#PBS -o ${LOG_DIR}/${JOB_NAME}.log
#PBS -W depend=afterok:${DEPS}

set -euo pipefail

module purge
module load netcdf cdo nco

IN_FILE="${IN_FILE}"
OUT_FILE="${OUT_FILE}"

ncpdq -O -a lat,lon,time --cnk_dmn time,${TIME_CHUNK_SIZE} --cnk_dmn lat,1 --cnk_dmn lon,1 -L${DEFLATE_LEVEL} "\${IN_FILE}" "\${OUT_FILE}"

EOF
	chmod u+x "${SCRIPT_FILE}"
	submit "${SCRIPT_FILE}"
}
